hazard <- haz_fit$hazard
haz_time <- haz_fit$time
hazard_plot <- plot(x = haz_time, y = hazard, xlab = 'Time', ylab = 'Hazard Rate', type = 'l',
xlim = c(min(haz_time), max(haz_time)), ylim = c(min(haz_fit$haz), max(haz_fit$haz)))
## Conditional survival
fit <- dynpred::Fwindow(object = surv_fit, width = 10, variance = TRUE, conf.level = 0.95)
con_time <- fit$time # the calculated times
con_death <- fit$Fw # conditional death
con_surv <- 1 - con_death # conditional survival; they are mirror images
plot(x = con_time, y = con_surv, type = 'l', col = 'green', xlab = 'Time',
ylab = 'Probability', main = 'Conditional survival and death over time',
ylim = c(0, 1), xlim = c(min(con_time), max(con_time)))
lines(con_time, con_death, col = 'red') # change the limit of the y-axis to c(0, 1) to see this
## Conditional survival
fit <- dynpred::Fwindow(object = surv_fit, width = 100, variance = TRUE, conf.level = 0.95)
con_time <- fit$time # the calculated times
con_death <- fit$Fw # conditional death
con_surv <- 1 - con_death # conditional survival; they are mirror images
plot(x = con_time, y = con_surv, type = 'l', col = 'green', xlab = 'Time',
ylab = 'Probability', main = 'Conditional survival and death over time',
ylim = c(0, 1), xlim = c(min(con_time), max(con_time)))
failures <- index(X = X, threshold = 14)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
legend(x = "center", legend = c('c = 1.3', 'n = 10000', 'nsim = 100', 'threshold = 7'))
hist(data$time, breaks = 100, xlab = 'Time', main = "Time distribution of transitions")
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
legend(x = "center", legend = c('c = 1.3', 'n = 10000', 'nsim = 100', 'threshold = 7'))
### Survival analysis
surv_data <- data.frame(Time = data$time, Event = data$event, row.names = paste0("Sim", 1:nrow(failures), ""))
surv_object <- Surv(time = data$time, event = data$event)
surv_fit <- survfit(surv_object ~ 1)
haz_fit <- bshazard::bshazard(surv_object ~ 1, data = surv_data)
survival <- surv_fit$surv
surv_time <- surv_fit$time
hazard <- haz_fit$hazard
haz_time <- haz_fit$time
hazard_plot <- plot(x = haz_time, y = hazard, xlab = 'Time', ylab = 'Hazard Rate', type = 'l',
xlim = c(min(haz_time), max(haz_time)), ylim = c(min(haz_fit$haz), max(haz_fit$haz)))
X <- lindynet(data = md_data, c = 1.75, n = 10000, nsim = 100)
failures <- index(X = X, threshold = 14)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
failures <- index(X = X, threshold = 2)
failures <- index(X = X, threshold = 12)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
failures <- index(X = X, threshold = 13)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
hist(data$time, breaks = 100, xlab = 'Time', main = "Time distribution of transitions")
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
failures <- index(X = X, threshold = 14)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
failures <- index(X = X, threshold = 2)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
failures <- index(X = X, threshold = 7)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
failures <- index(X = X, threshold = 10)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
failures <- index(X = X, threshold = 12)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
legend(x = "center", legend = c('c = 1.3', 'n = 10000', 'nsim = 100', 'threshold = 7'))
### Survival analysis
surv_data <- data.frame(Time = data$time, Event = data$event, row.names = paste0("Sim", 1:nrow(failures), ""))
surv_object <- Surv(time = data$time, event = data$event)
surv_fit <- survfit(surv_object ~ 1)
haz_fit <- bshazard::bshazard(surv_object ~ 1, data = surv_data)
survival <- surv_fit$surv
surv_time <- surv_fit$time
hazard <- haz_fit$hazard
haz_time <- haz_fit$time
hazard_plot <- plot(x = haz_time, y = hazard, xlab = 'Time', ylab = 'Hazard Rate', type = 'l',
xlim = c(min(haz_time), max(haz_time)), ylim = c(min(haz_fit$haz), max(haz_fit$haz)))
failures <- index(X = X, threshold = 13)
data <- as.data.frame(failures)
hist(data$time, breaks = 10, xlab = 'Time', main = "Time distribution of transitions")
### Survival analysis
surv_data <- data.frame(Time = data$time, Event = data$event, row.names = paste0("Sim", 1:nrow(failures), ""))
surv_object <- Surv(time = data$time, event = data$event)
surv_fit <- survfit(surv_object ~ 1)
haz_fit <- bshazard::bshazard(surv_object ~ 1, data = surv_data)
survival <- surv_fit$surv
surv_time <- surv_fit$time
hazard <- haz_fit$hazard
haz_time <- haz_fit$time
hazard_plot <- plot(x = haz_time, y = hazard, xlab = 'Time', ylab = 'Hazard Rate', type = 'l',
xlim = c(min(haz_time), max(haz_time)), ylim = c(min(haz_fit$haz), max(haz_fit$haz)))
## Conditional survival
fit <- dynpred::Fwindow(object = surv_fit, width = 100, variance = TRUE, conf.level = 0.95)
con_time <- fit$time # the calculated times
con_death <- fit$Fw # conditional death
con_surv <- 1 - con_death # conditional survival; they are mirror images
plot(x = con_time, y = con_surv, type = 'l', col = 'green', xlab = 'Time',
ylab = 'Probability', main = 'Conditional survival and death over time',
ylim = c(0, 1), xlim = c(min(con_time), max(con_time)))
lines(con_time, con_death, col = 'red') # change the limit of the y-axis to c(0, 1) to see this
## A function for the symptom level
symptom <- function(x, n){
event <- numeric(length = ncol(X))
dead_start <- numeric(length = ncol(X))
dead_end <- numeric(length = ncol(X))
data_from_birth <- numeric()
rle_data <- numeric()
values <- numeric() # Values in the symptom: 0-1-0
reps <- numeric() # How many times each value repeats
start <- numeric(length = ncol(X))
for(j in 1:ncol(X)){ # First indexing the jth column of X
data <- cbind(X[,j])
start[j] <- start_fun(data) # When the symptom is 1 for the first time in column j of X
}
for(j in 1:length(start)){
data_from_birth <- data[start[j]:nrow(data),]
rle_data <- rle(as.vector(data_from_birth))
values <- rle_data[[2]]
reps <- rle_data[[1]]
}
for(i in 1:length(values)){
for(j in 1:length(event)){
if(values[i] == 0 & reps[i] >= 2){
event[j] <- 1
break
}
}
}
for(i in 1:length(values)){
for(j in 1:length(event)){
if(values[i] == 0 & !(any(reps[i] >= 2))){
event[j] <- 0
}
}
}
rep_deaths <- which(values == 0 & reps >= 2)
deaths.lengths.cumsum <- cumsum(reps)
ends <- deaths.lengths.cumsum[rep_deaths] # Until which time point the symptom remained 0.
newindex <- ifelse(rep_deaths > 1, rep_deaths-1, 0)
dead <- deaths.lengths.cumsum[newindex] + 1
if (0 %in% newindex){
dead <- c(1, dead)} #The start point of death (0).
for(j in 1:length(start)){
if(event == 1){
time <- start[j] + dead - 1 # The point at which it starts being 0 in succession
time_2 <- start[j] + ends - 1 # The last 0 in the succession of 0s
} else {
time <- nrow(s1)
time_2 <- nrow(s1)
}
}
return(dead_end)
}
class(X)
dim(X)
X
X[1,]
X["Network1",]
## A function for the symptom level
symptom <- function(X, n){
event <- numeric(length = ncol(X))
dead_start <- numeric(length = ncol(X))
dead_end <- numeric(length = ncol(X))
data_from_birth <- numeric()
rle_data <- numeric()
values <- numeric() # Values in the symptom: 0-1-0
reps <- numeric() # How many times each value repeats
start <- numeric(length = ncol(X))
for(j in 1:ncol(X)){ # First indexing the jth column of X
data <- cbind(X[,j])
start[j] <- start_fun(data) # When the symptom is 1 for the first time in column j of X
}
for(j in 1:length(start)){
data_from_birth <- data[start[j]:nrow(data),]
rle_data <- rle(as.vector(data_from_birth))
values <- rle_data[[2]]
reps <- rle_data[[1]]
}
for(i in 1:length(values)){
for(j in 1:length(event)){
if(values[i] == 0 & reps[i] >= 2){
event[j] <- 1
break
}
}
}
for(i in 1:length(values)){
for(j in 1:length(event)){
if(values[i] == 0 & !(any(reps[i] >= 2))){
event[j] <- 0
}
}
}
rep_deaths <- which(values == 0 & reps >= 2)
deaths.lengths.cumsum <- cumsum(reps)
ends <- deaths.lengths.cumsum[rep_deaths] # Until which time point the symptom remained 0.
newindex <- ifelse(rep_deaths > 1, rep_deaths-1, 0)
dead <- deaths.lengths.cumsum[newindex] + 1
if (0 %in% newindex){
dead <- c(1, dead)} #The start point of death (0).
for(j in 1:length(start)){
if(event == 1){
time <- start[j] + dead - 1 # The point at which it starts being 0 in succession
time_2 <- start[j] + ends - 1 # The last 0 in the succession of 0s
} else {
time <- nrow(s1)
time_2 <- nrow(s1)
}
}
return(dead_end)
}
symptom(X = X["Network1",], n = 1)
class(X["Network1",])
network <- X["Network1",]
network
network <- as.matrix(X["Network1",])
network
## A function for the symptom level
symptom <- function(data, c, n){ # data is a matrix
# c is the connectivity parameter
# n is the number of time points
####### Fitting the Ising model to estimate weights and biases #######
fit <- IsingFit::IsingFit(x = data) # x must be cross-sectional data
####### Creating the network #######
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
states <- apply(X, 1, sum)
return(X)
}
X
## Arithmetic Brownian Motion (resamples until the value is below the reflecting barrier)
my_abm <- function(nsim, t0, t, n, X0, mu, sigma, L, R){
dt <- t/n
time <- seq(from = t0, to = t, by = dt)
initial <- X0
X <- matrix(nrow = nsim, ncol = length(time))
X[1:nsim, 1] <- X0
event_time <- numeric(length = nsim)
event_status <- numeric(length = nsim)
for(i in 1:nrow(X)){
for(j in 2:length(time)){
X[i,j] <- X0 + mu * dt + sigma * sqrt(dt) * rnorm(n = 1, mean = 0, sd = 1)
while(X[i,j] > R){ # simulate data as long as it's above the reflecting barrier
X[i,j] <- X0 + mu * dt + sigma * sqrt(dt) * rnorm(n = 1, mean = 0, sd = 1)
if(X[i,j] <= R) { # if we are below or equal, the value stays the same
X[i,j] <- X[i,j]
}
}
if(X[i,j] > L & j < ncol(X)){
X0 <- X[i,j]
} else if(X[i,j] > L & j == ncol(X)){
X0 <- initial
event_time[i] <- ncol(X)
event_status[i] <- 0
} else if(X[i,j] <= L){
X[i,j] <- L
X0 <- initial
event_time[i] <- j
event_status[i] <- 1
break
}
}
values <- list("Values" = X, "Event time" = event_time, "Event status" = event_status)
}
return(values)
}
## Geometric Brownian Motion (the new value equals the reflecting barrier until it is below it)
my_gbm <- function(nsim, t0, t, n, X0, mu, sigma, L, R){
dt <- t/n
sig2 <- sigma^2
time <- seq(from = t0, to = t, by = dt)
initial <- X0
X <- matrix(nrow = nsim, ncol = length(time))
X[1:nsim, 1] <- X0
event_time <- numeric(length = nsim)
event_status <- numeric(length = nsim)
for(i in 1:nrow(X)){
for(j in 2:length(time)){
X[i,j] <- X0 * exp(((mu - 0.5 * sig2) * dt) + (sigma * sqrt(dt) * rnorm(n = 1, mean = 0, sd = 1))) # the formula for the next value of BM
if(X[i,j] > R){ # if above the barrier, the new value is the barrier level
X[i,j] <- R
} else if(X[i,j] <= R) { # otherwise it's the simulated value
X[i,j] <- X[i,j]
}
if(X[i,j] > L & j < ncol(X)){
X0 <- X[i,j]
} else if(X[i,j] > L & j == ncol(X)){
X0 <- initial
event_time[i] <- ncol(X)
event_status[i] <- 0
} else if(X[i,j] <= L){
X0 <- initial
event_time[i] <- j
event_status[i] <- 1
break
}
}
values <- list("Values" = X, "Event time" = event_time, "Event status" = event_status)
}
return(values)
}
### Simulations
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
# A function to store the BM values in a nice form
values <- function(x, nsim, n){
u <- unlist(x)
u <- u[-which(names(u) == "Event time")]
u <- u[-which(names(u) == "Event status")]
m <- matrix(data = u, nrow = nsim, ncol = length(0:n), byrow = TRUE)
df <- data.frame(x = t(m), row.names = paste0("Time", 0:n, ""))
colnames(x = df) <- paste0("Sim", 1:nsim, "")
store <- list(m, df)
return(store)
}
# A function to store the hitting times
times <- function(x, nsim, n){
u <- unlist(x)
u <- u[-which(names(u) != "Event time")]
m <- matrix(data = u, nrow = nsim, ncol = 1, byrow = TRUE)
df <- data.frame(x = m, row.names = paste0("Sim", 1:nsim, ""))
colnames(x = df) <- "Hitting time"
store <- list(m, df)
return(store)
}
# A function to store the event / censoring times
events <- function(x, nsim, n){
u <- unlist(x)
u <- u[-which(names(u) != "Event status")]
m <- matrix(data = u, nrow = nsim, ncol = 1, byrow = TRUE)
df <- data.frame(x = m, row.names = paste0("Sim", 1:nsim, ""))
colnames(x = df) <- "Event"
store <- list(m, df)
return(store)
}
## Parallel runs
f <- function(i){ # specify the desired function and parameter values here
my_gbm(nsim = 1, t0 = 0, t = 1, n = 10000, X0 = 100, mu = -1, sigma = 1, L = 90, R = 11000000000)
#my_abm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 0, mu = 0, sigma = 1, L = -0.1, R = 10000000)
}
set.seed(1)
res <- mclapply(X = 1:10000, f, mc.cores = 8, mc.set.seed = TRUE)
v <- values(x = res, nsim = 10000, n = 10000) # indexing the BM values
m_val <- v[[1]] # BM values in a matrix (goes into the plotting function)
df_val <- v[[2]] # BM values in a data frame
t <- times(x = res, nsim = 10000, n = 10000) # indexing the hitting times
m_times <- t[[1]] # in a matrix (for histograms)
df_times <- t[[2]] # in a data frame
e <- events(x = res, nsim = 10000, n = 10000)
m_event <- e[[1]]
df_event <- e[[2]]
data <- cbind(df_times, df_event)
### Survival analysis
surv_data <- data.frame(Time = data$`Hitting time`, Event = data$Event, row.names = paste0("Sim", 1:nrow(m_times), ""))
surv_object <- Surv(time = data$`Hitting time`, event = data$Event)
surv_fit <- survfit(surv_object ~ 1)
haz_fit <- bshazard::bshazard(surv_object ~ 1, data = surv_data)
survival <- surv_fit$surv
surv_time <- surv_fit$time
hazard <- haz_fit$hazard
haz_time <- haz_fit$time
hazard_plot <- plot(x = haz_time, y = hazard, xlab = 'Time', ylab = 'Hazard Rate', type = 'l',
xlim = c(min(haz_time), max(haz_time)), ylim = c(min(haz_fit$haz), max(haz_fit$haz)))
## Conditional survival
fit <- dynpred::Fwindow(object = surv_fit, width = 1, variance = TRUE, conf.level = 0.95)
con_time <- fit$time # the calculated times
con_death <- fit$Fw # conditional death
con_surv <- 1 - con_death # conditional survival; they are mirror images
plot(x = con_time, y = con_surv, type = 'l', col = 'green', xlab = 'Time',
ylab = 'Probability', main = 'Conditional survival and death over time',
ylim = c(0, 1), xlim = c(min(con_time), max(con_time)))
## Conditional survival
fit <- dynpred::Fwindow(object = surv_fit, width = 100, variance = TRUE, conf.level = 0.95)
con_time <- fit$time # the calculated times
con_death <- fit$Fw # conditional death
con_surv <- 1 - con_death # conditional survival; they are mirror images
plot(x = con_time, y = con_surv, type = 'l', col = 'green', xlab = 'Time',
ylab = 'Probability', main = 'Conditional survival and death over time',
ylim = c(0, 1), xlim = c(min(con_time), max(con_time)))
## Conditional survival
fit <- dynpred::Fwindow(object = surv_fit, width = 1000, variance = TRUE, conf.level = 0.95)
con_time <- fit$time # the calculated times
con_death <- fit$Fw # conditional death
con_surv <- 1 - con_death # conditional survival; they are mirror images
plot(x = con_time, y = con_surv, type = 'l', col = 'green', xlab = 'Time',
ylab = 'Probability', main = 'Conditional survival and death over time',
ylim = c(0, 1), xlim = c(min(con_time), max(con_time)))
## Conditional survival
fit <- dynpred::Fwindow(object = surv_fit, width = 100, variance = TRUE, conf.level = 0.95)
con_time <- fit$time # the calculated times
con_death <- fit$Fw # conditional death
con_surv <- 1 - con_death # conditional survival; they are mirror images
plot(x = con_time, y = con_surv, type = 'l', col = 'green', xlab = 'Time',
ylab = 'Probability', main = 'Conditional survival and death over time',
ylim = c(0, 1), xlim = c(min(con_time), max(con_time)))
lines(con_time, con_death, col = 'red') # change the limit of the y-axis to c(0, 1) to see this
X
## This function computes the total number of active symptoms at each time point for n networks
lindynet <- function(data, c, n, nsim) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
####### Fitting the Ising model to estimate weights and biases #######
fit <- IsingFit::IsingFit(x = data) # x must be cross-sectional data
####### Creating the network #######
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
states <- apply(X, 1, sum)
f <- function(i){
states(data = data, c = c, n = n)
}
res <- matrix(data = replicate(n = nsim, expr = states(data = data, c = c, n = n)),
nrow = nsim, ncol = n, byrow = TRUE)
dimnames(res) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(res)
}
lindynet(data = md_data, c = 2, n = 10, nsim = 1)
# For each network, index when they are depressed for the first time
survnet <- function(X, threshold) { # X is the output matrix of the lindynet function
# threshold is the required number of active symptoms for depression
start <- numeric(length = nrow(X))
for(i in 1:nrow(X)) {
start[i] <- which(X[i,] >= threshold)[1]
}
if(any(is.na(start)) == TRUE) {
X <- X[-(which(is.na(start) == TRUE)), ] # remove the networks that never became depressed
} else {
X <- X
}
start <- start[!is.na(start)]
time <- numeric(length = nrow(X))
event <- numeric(length = nrow(X))
for(i in 1:nrow(X)) {
for(j in start[i]:ncol(X)) {
if(X[i, j] >= threshold & j < ncol(X)) {
time[i] <- time[i] + 1
} else if(X[i, j] >= threshold & j == ncol(X)) {
time[i] <- time[i]
event[i] <- 0
} else if(X[i, j] < threshold) {
time[i] <- time[i]
event[i] <- 1
break
}
}
}
data <- cbind(event, time)
row.names(data) <- paste0("Network", 1:nrow(X), "")
return(data)
}
set.seed(1)
X <- lindynet(data = md_data, c = 1.3, n = 10000, nsim = 2)
X
## This function computes the total number of active symptoms at each time point for n networks
lindynet <- function(data, c, n, nsim) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
states <- function(data, c, n) {
####### Fitting the Ising model to estimate weights and biases #######
fit <- IsingFit::IsingFit(x = data) # x must be cross-sectional data
####### Creating the network #######
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
states <- apply(X, 1, sum)
return(states)
}
f <- function(i){
states(data = data, c = c, n = n)
}
res <- matrix(data = replicate(n = nsim, expr = states(data = data, c = c, n = n)),
nrow = nsim, ncol = n, byrow = TRUE)
dimnames(res) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(res)
}
set.seed(1)
X <- lindynet(data = md_data, c = 1.3, n = 10000, nsim = 2)
X <- lindynet(data = md_data, c = 1.3, n = 10, nsim = 2)
X
X <- lindynet(data = md_data, c = 1.3, n = 10, nsim = 2)
X
X <- lindynet(data = md_data, c = 1.3, n = 10000, nsim = 2)
survnet(X = X, threshold = 1)
set.seed(1)
X <- lindynet(data = md_data, c = 1.3, n = 10, nsim = 2)
X
set.seed(1)
X <- lindynet(data = md_data, c = 1.3, n = 10, nsim = 2)
