v <- values(x = res, nsim = 100, n = 1000) # indexing the BM values
m_val <- v[[1]] # BM values in a matrix (goes into the plotting function)
df_val <- v[[2]] # BM values in a data frame
t <- times(x = res, nsim = 100, n = 1000) # indexing the hitting times
m_times <- t[[1]] # in a matrix (for histograms)
df_times <- t[[2]] # in a data frame
e <- events(x = res, nsim = 100, n = 1000)
m_event <- e[[1]] # in a matrix
df_event <- e[[2]]
p <- bmplot(x = m_val, nsim = 100, n = 1000, L = 0, ylim = c(0, 100), # Define the range of the y-axis
title = "Arithmetic Brownian motion with negative drift")
print(p)
## Parallel runs
f <- function(i){ # specify the desired function and parameter values here
my_gbm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 100, mu = -3, sigma = 0.5, L = -10)
#my_abm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 1, mu = -3, sigma = 0.5, L = -10)
}
set.seed(1)
res <- mclapply(X = 1:100, f, mc.cores = 8, mc.set.seed = TRUE)
v <- values(x = res, nsim = 100, n = 1000) # indexing the BM values
m_val <- v[[1]] # BM values in a matrix (goes into the plotting function)
df_val <- v[[2]] # BM values in a data frame
t <- times(x = res, nsim = 100, n = 1000) # indexing the hitting times
m_times <- t[[1]] # in a matrix (for histograms)
df_times <- t[[2]] # in a data frame
e <- events(x = res, nsim = 100, n = 1000)
m_event <- e[[1]] # in a matrix
df_event <- e[[2]]
p <- bmplot(x = m_val, nsim = 100, n = 1000, L = 0, ylim = c(0, 100), # Define the range of the y-axis
title = "Arithmetic Brownian motion with negative drift")
print(p)
## Parallel runs
f <- function(i){ # specify the desired function and parameter values here
my_gbm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 100, mu = -2, sigma = 0.5, L = -10)
#my_abm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 1, mu = -3, sigma = 0.5, L = -10)
}
set.seed(1)
res <- mclapply(X = 1:100, f, mc.cores = 8, mc.set.seed = TRUE)
v <- values(x = res, nsim = 100, n = 1000) # indexing the BM values
m_val <- v[[1]] # BM values in a matrix (goes into the plotting function)
df_val <- v[[2]] # BM values in a data frame
t <- times(x = res, nsim = 100, n = 1000) # indexing the hitting times
m_times <- t[[1]] # in a matrix (for histograms)
df_times <- t[[2]] # in a data frame
e <- events(x = res, nsim = 100, n = 1000)
m_event <- e[[1]] # in a matrix
df_event <- e[[2]]
p <- bmplot(x = m_val, nsim = 100, n = 1000, L = 0, ylim = c(0, 100), # Define the range of the y-axis
title = "Arithmetic Brownian motion with negative drift")
print(p)
## Parallel runs
f <- function(i){ # specify the desired function and parameter values here
my_gbm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 100, mu = -2, sigma = 0.35, L = -10)
#my_abm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 1, mu = -3, sigma = 0.5, L = -10)
}
set.seed(1)
res <- mclapply(X = 1:100, f, mc.cores = 8, mc.set.seed = TRUE)
v <- values(x = res, nsim = 100, n = 1000) # indexing the BM values
m_val <- v[[1]] # BM values in a matrix (goes into the plotting function)
df_val <- v[[2]] # BM values in a data frame
t <- times(x = res, nsim = 100, n = 1000) # indexing the hitting times
m_times <- t[[1]] # in a matrix (for histograms)
df_times <- t[[2]] # in a data frame
e <- events(x = res, nsim = 100, n = 1000)
m_event <- e[[1]] # in a matrix
df_event <- e[[2]]
p <- bmplot(x = m_val, nsim = 100, n = 1000, L = 0, ylim = c(0, 100), # Define the range of the y-axis
title = "Arithmetic Brownian motion with negative drift")
print(p)
my_gbm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 100, mu = -2, sigma = 0.45, L = -10)
## Parallel runs
f <- function(i){ # specify the desired function and parameter values here
my_gbm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 100, mu = -2, sigma = 0.45, L = -10)
#my_abm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 1, mu = -3, sigma = 0.5, L = -10)
}
set.seed(1)
res <- mclapply(X = 1:100, f, mc.cores = 8, mc.set.seed = TRUE)
v <- values(x = res, nsim = 100, n = 1000) # indexing the BM values
m_val <- v[[1]] # BM values in a matrix (goes into the plotting function)
df_val <- v[[2]] # BM values in a data frame
t <- times(x = res, nsim = 100, n = 1000) # indexing the hitting times
m_times <- t[[1]] # in a matrix (for histograms)
df_times <- t[[2]] # in a data frame
e <- events(x = res, nsim = 100, n = 1000)
m_event <- e[[1]] # in a matrix
df_event <- e[[2]]
p <- bmplot(x = m_val, nsim = 100, n = 1000, L = 0, ylim = c(0, 100), # Define the range of the y-axis
title = "Arithmetic Brownian motion with negative drift")
print(p)
## Parallel runs
f <- function(i){ # specify the desired function and parameter values here
my_gbm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 100, mu = -2, sigma = 0.3, L = -10)
#my_abm(nsim = 1, t0 = 0, t = 1, n = 1000, X0 = 1, mu = -3, sigma = 0.5, L = -10)
}
set.seed(1)
res <- mclapply(X = 1:100, f, mc.cores = 8, mc.set.seed = TRUE)
v <- values(x = res, nsim = 100, n = 1000) # indexing the BM values
m_val <- v[[1]] # BM values in a matrix (goes into the plotting function)
df_val <- v[[2]] # BM values in a data frame
t <- times(x = res, nsim = 100, n = 1000) # indexing the hitting times
m_times <- t[[1]] # in a matrix (for histograms)
df_times <- t[[2]] # in a data frame
e <- events(x = res, nsim = 100, n = 1000)
m_event <- e[[1]] # in a matrix
df_event <- e[[2]]
p <- bmplot(x = m_val, nsim = 100, n = 1000, L = 0, ylim = c(0, 100), # Define the range of the y-axis
title = "Arithmetic Brownian motion with negative drift")
print(p)
p <- bmplot(x = m_val, nsim = 100, n = 1000, L = 0, ylim = c(0, 100), # Define the range of the y-axis
title = "Geometric Brownian motion with negative drift")
print(p)
install.packages("IsingFit")
### Libraries
library(IsingFit)
library(parallel)
setwd("~/Desktop/GitHub/bm-simulations/Data")
### Load the data
data <- read.table("md_data.txt", header = F)
md_data <- data.matrix(data)
colnames(md_data) <- c("dep", "int", "los", "gai", "dap", "iap", "iso", "hso", "agi",
"ret", "fat", "wor", "con", "dea")
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # now W has 3 matrices, each with the original weights multiplied by a connectivity value
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
# Running the simulations in parallel
sims <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
state(data = data, c = c, n = n)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
set.seed(1)
states <- sims(data = md_data, c = 1.2, n = 4, nsim = 2)
install.packages("parallel")
install.packages("parallel")
library(parallel)
### Load the data
data <- read.table("md_data.txt", header = F)
md_data <- data.matrix(data)
colnames(md_data) <- c("dep", "int", "los", "gai", "dap", "iap", "iso", "hso", "agi",
"ret", "fat", "wor", "con", "dea")
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # now W has 3 matrices, each with the original weights multiplied by a connectivity value
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
# Running the simulations in parallel
sims <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
state(data = data, c = c, n = n)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
set.seed(1)
states <- sims(data = md_data, c = 1.2, n = 4, nsim = 2)
### Load the data
md_data <- data.matrix(read.table("md_data.txt", header = F))
colnames(md_data) <- c("dep", "int", "los", "gai", "dap", "iap", "iso", "hso", "agi",
"ret", "fat", "wor", "con", "dea")
md_data
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(X)
}
state(data = md_data, c = 1.2, n = 10)
### Libraries
library(IsingFit)
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(X)
}
state(data = md_data, c = 1.2, n = 10)
state(data = md_data, c = 2, n = 10)
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
state(data = md_data, c = 2, n = 10)
set.seed(1)
state(data = md_data, c = 2, n = 10)
set.seed(1)
state(data = md_data, c = 2, n = 10)
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(X)
}
set.seed(1)
state(data = md_data, c = 2, n = 10)
mom <- matrix(data = 1:16, nrow = 4, ncol = 4)
mom
apply(mom, 1, sum)
# Running the simulations in parallel
sims <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
state(data = data, c = c, n = n)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
set.seed(1)
states <- sims(data = md_data, c = 1.2, n = 4, nsim = 2)
states
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
# Running the simulations in parallel
sims <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
state(data = data, c = c, n = n)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
set.seed(1)
states <- sims(data = md_data, c = 1.2, n = 4, nsim = 2)
states
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n, nsim) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
state(data = md_data, c = 1.2, n = 10, nsim = 10)
state(data = md_data, c = 1.2, n = 10)
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
state(data = md_data, c = 1.2, n = 10)
# Running the simulations in parallel
sims <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
state(data = data, c = c, n = n)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
state(data = md_data, c = 1.2, n = 10)
## Creating a function that returns the states over time for each connectivity level.
## No stress parameter.
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
# Running the simulations in parallel
sims <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
state(data = data, c = c, n = n)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
set.seed(1)
states <- sims(data = md_data, c = 1.2, n = 4, nsim = 2)
states
# Running the simulations in parallel
lindynet <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
state <- function(data, c, n) { # data is a matrix
# c is the connectivity parameter
# n is the number of time points
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
state(data = data, c = c, n = n)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
states <- sims(data = md_data, c = 1.2, n = 4, nsim = 2)
states <- lindynet(data = md_data, c = 1.2, n = 4, nsim = 2)
states
# Running the simulations in parallel
lindynet <- function(data, c, n, nsim) { # connectivity, number of time points, number of networks to be simulated
RNGkind("L'Ecuyer-CMRG") # this is the random number generator needed in parallel processing
detectCores() # tells you the number of cores your computer can use for the simulations
f <- function(i) { # specify the desired function and parameter values here
################ Fitting the Ising model to estimate weights and biases ################
fit <- IsingFit(data) # x must be cross-sectional data
################ Creating the network ################
j <- ncol(data) # number of symptoms
b <- abs(fit$thresholds) # thresholds
W <- fit$weiadj # weights
P <- X <- matrix(0, n, j) # matrix with probabilities (P) and simulated data (X); full of 0s initially
W <- c * W # multiply the weights by the connectivity parameter
for (t in 2:n) {
A <- X[t - 1,] %*% W # the activation function (formula (1) in paper)
P[t,] <- 1 / (1 + exp(b - A)) # the probability function (formula (2) in paper)
X[t,] <- 1 * (P[t,] > runif(j)) # symptom i becomes active ( = 1) if the probability is greater than randomly chosen uniformly distributed number between 0 and 1
}
state <- apply(X, 1, sum)
return(state)
}
res <- unlist(mclapply(X = 1:nsim, f, mc.cores = 8, mc.set.seed = TRUE))
states <- matrix(data = res, nrow = nsim, ncol = n, byrow = TRUE)
dimnames(states) <- list(paste0("Network", 1:nsim, ""), paste0("t", 1:n, ""))
return(states)
}
set.seed(1)
states <- lindynet(data = md_data, c = 1.2, n = 4, nsim = 2)
states
?parSapply
